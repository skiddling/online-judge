#tips:
>0.dp首先是无后效性的最优化问题，问题的本质其实就是通过能实现的所有操作叠加起来然后得到的一个最优解，所以我们需要搞明白以下几个点

>1.要弄清可选策略有哪几种

>2.要找出状态转移的方向（通过题目然后找到当中转移的方向）比如线性的从做到右，数字从大到小，树形的从根到叶子或者从叶子到根，也就是策略（操作）的执行方向

>3.在实现上面两点的过程当中我们也应该确定该定义怎么样的状态空间和各种子状态
- - -

>在这个6d的问题当中我们首先要发现其实他要求的是一个操作序列，而所有这些操作的序列其实是和后面的操作无关的，也就是说你当前的状态只和你之前一个的状态有关，也就是你当前的状态和操作只能影响你下一个阶段的状态和操作，该当前节点的下一个阶段的状态和操作与当前状态之前的状态都没有关系，也就是只有相邻的两个状态节点会相互影响，而和其他不相邻的（如果是一个无向图也就是说没有边连着的两个点之间是没有任何关系）（说的更简单点就是要求一个最优解，那么该解的每一个阶段都要通过最优的转移方法来实现，让每个阶段都是最优的，贪心则只是因为通过某些性质能够直接知道一步登天的那种全局最优，而dp则需要时分阶段的阶段最优，两者的区别）

>而在这个问题当中我们发现状态可以由左往右或者从右往左传递，从而我们可以根据这一个特点进行设计状态和状态空间

- - -

2015.11.23补
>关于解题的一些思路的补充

>首先从题目中我们能够得到的信息是我们只会进行一个操作，就是扔炸弹，但是在扔炸弹的过程当中会因为我们在每个地方扔的炸弹数量的不同导致最终我们一共需要扔的炸弹的数量的不同，也就是一种类似于操作的序列的组合，也就是所有操作的，而且这个组合与扔炸弹的先后次序无关，也就是满足无后效性，然后我们可以发现如果我们从某一边开始向另外一边开始扔炸弹，我们扔过的地方的左边肯定已经不用再继续扔了，所以我们发现了一个可以进行运算的方向，比如从左到右或者从右到左的顺序，至此我们已经定义好了问题的框架，也已经得到了运算的顺序，要解决问题我们现在只需要设计一个能够让我们求得解得状态，以及相应的整个状态空间

>我们这里需要回到最开始的问题当中给出的操作再来进行整个的考虑，**因为我们要明确的一点是我们所设计的状态要能够把每次对状态的操作所带来的影响（结果）都记录下来（而记录就需要设计相应维度的数组或者是结构体）**，所以我们这里再来仔细考虑题目给出的操作有哪些效果（其实这里是一种对实际问题的抽象），**单独考虑每次操作和题目所求，一次操作影响一个状态，而每个状态又和我们需要求结果有关**，通过每次操作我们发现如果我们在m点扔一次炸弹，那么m点受到a点伤害，m点左边的l点和右边的r点受到b点伤害，且我们如果在l点扔x个，m点y个，r点扔z个，那么m点的弓箭手一定要死亡，从此处我们考虑，设初始态是f(1,0,m,r)表示我们从该状态出发所需要最少扔几次，f(n-1,l,m,0)表示最右边的那个状态，可直接算出来，从而该问题可以得到解决。

>在实现的时候我们可以对存储空间进行一个优化，因为我们在处理f(i,l,m,r)的时候其实是把每个方案的最少值都进行了保存，但是我们只要求得到一个最优解就可以了，所以其实我们只需要i,l,m这三个参数，并用next(i,l,m)来记录r处扔多少个才能得到该最优解，然后对r处需要扔的个数进行枚举即可，然后通过遍历找到最佳方案的r的值并记录下来，从而可以得到解

- - -

##关于实现
>首先是关于状态的设计，一般是从问题给出的操作以及问题的所求来搞，这三者的关系可以粗略的看成一个函数，状态的设计是函数的参数，操作是函数的操作，也就是对参数的操作，而问题的求解也就是函数的返回值，所以我们应该从已知的操作和求解的问题来设计与他们两个相适应的状态

>关于dp，我们需要根据已经设计好的状态来选择究竟是递推还是递归，如果设计的状态适合直接从当前状态节点从之前的节点直接获得需要信息，那么选择递推，反之就是尝试递归的方法，递推就不在此处讲了，说说递归的方法

>首先我们还是要明确dp的作用是通过无后效性这个特点来对整个的流程进行时间上的优化，也就是说只要状态设计好我们都可以通过搜索的方法来得到需要的解，但是往往时间复杂度过高，所以我们可以对问题进行分析之后对算法进行优化，比如对于最优化的问题，我们如果通过分析发现问题可以用贪心那么就可以直接进行计算得到全局最优解，**但是如果是具有无后效性的多阶段的决策问题，也就是每个状态都是由多个操作的不同影响一起叠加所带来的**，那么我们就可以采用dp，然后对每个阶段的决策都进行相应的最优化，从而得到一个全局最优化的解，而正因为是求最优解，所以我们在搜索的时候我们只需要进行记录相应的每个阶段的最优解，就可以避免做以往重复做的事情，相当于我们直接查阅有没有该状态的记录，如果有就直接返回该记录，没有就去寻找该解，并返回的时候将该最优解记录下来，其实这里已经体现了一个前序dfs，而这种dfs函数基本都是有返回值的，返回值也就是该状态的解

>此处讲一讲带返回值的dfs和不带返回值的dfs，在很多单纯的搜索问题当中我们往往只需要通过dfs到达目标节点然后找到一个或者多个解然后将他们记录下来就行，在这样的问题当中我们往往更关心的是dfs去通过怎么样的搜索方式来进行状态之间的转换而并不关心状态结束之后的返回，因为我们只需要设置一个全局变量，然后在当dfs到达目标节点然后找到解得时候通过这个全局变量将这个解记录下来即可，或者是通过返回值的方式将这个值原路返回，这两个方式都可以在该问题当中获得最同样的答案，**即dfs当中单一的返回值和全局变量在目标节点记录该返回值在效果上是等价的**，但是对于递归的dp(记忆化搜索)而言，因为我们需要对中间的每一个状态都进行相应的记录，所以我们需要让dfs有返回值，然后通过相应的变量来存储这些返回来的状态值，这一点如果只是单单通过一个全局变量在目标节点记录一个解释不可行的，**我们需要设置一个全局变量然后将当中每一个返回值都记录下来**，也就是不止记录一次

>最后再来讲讲dp的方向性，dp的方向总是相似的，就是都是从底层状态开始不断的像高层的状态不断的推进，**bottom to top**，当中如果发现可以直接从底层的状态转到下一个高层状态那我们往往都选择递推，也就是高层状态节点可以直接获得与它相连的低层状态节点的值，如果不能直接获得那么我们往往都还是采用最记忆化搜索的方式来进行获得，也就是从最高的状态出发一路向底层状态前进，然后到了最底层之后再递归回来，从而获得最后的高层的状态的值，而且基本都是用**前序dfs**的方式进行搜索，也就是将每个节点的子节点都遍历完了之后再返回给父节点，这个方式也是唯一能满足记忆化搜索要求的搜索方式

